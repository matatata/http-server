<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head>   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="GENERATOR" content="Mozilla/4.5 [de] (Macintosh; I; PPC) [Netscape]">   <title>index.html</title></head><body><h1>Caching Web Proxy</h1><p><br>Assignment 3 of <a href="http://www.tk.informatik.tu-darmstadt.de/Lehre/ss04/DigiPrak/en_index_html">PracticalCourse "Internet - The Next Generation"</a><p>Matteo Ceruti <a href="mailto:ceruti@rbg.informatik.tu-darmstadt.de">&lt;ceruti@rbg.informatik.tu-darmstadt.de></a><br>Semester: 10<br>Matrikel: 953982<br>Studiengang: Dipl-Informatik<h2>Features &amp; Information</h2><ul><li><b>Built in Web-Server HTTP/1.0/1.1</b></li><ul><li>HTTP/1.0 &amp; HTTP/1.1</li><ul><li>GET</li><li>Content-Type mappings from external file (mime.types)</li></ul><li>HTTP/1.1</li><ul><li>IF-GET is treated as GET</li><li>Byte-Ranges (see RFC chapter 14.35) are quite fully supported, except theIf-Range header-field.</li><br>Some Browsers support stopping and resuming downloads, e.g. Safariuses Byte-Ranges to resume downloads.<ul><li>If unsatisfyable, answers with appropriate server-message "Requested rangenot satisfiable"</li></ul></ul></ul><li><b>Proxy</b></li><ul><li>Works with HTTP/1.0 and 1.1 Clients</li><li>supports GET, POST requests</li><li>quite transparent</li><ul><li>except:</li><ul><li>Connection header-fields are overridden</li><li>Byte-Ranges Request can be forwarded (depends on configuration)</li></ul></ul><li>Data is beeing directly forwarded, not buffered!</li></ul><li><b>Cache</b> (not a real Cache)</li><ul><li>caches 200 "OK" Responses except for POST-Requests</li><li>uses md5-Hashes for identification</li><li>logging to a <a href="/cache/toc.html">/cache/toc.html</a> for offline-browsing</li><li>Caching is carefully synchronized to guarantee consistency and acceptableperformance (Thread-Safe)</li><ul><li>Broken Pipes and dropped connections, I/O-Exceptions are recovered!</li><li>No corrupted or incomplete data will be stored! (uses commit/rollback-mechanism)</li></ul><li>Caching occurs simultanously while data beeing sent to client.</li><li>When serving a copy to a client, the data is beeing converted if necessary.</li><ul><li>data will be unchunked on the fly for HTTP/1.0-clients</li><li>decodes gzip (x-gzip), deflate (x-deflate) on the fly</li><li>can answer Byte-Ranges-requests (responds 206 Responses)</li><ul><li>depending on what has been cached, the data will be decoded and bufferedin order to satisfy byte-ranges before sent as 206 "Partial Response"</li><li>If unsatisfyable, answers with appropriate Server-Message "Requested rangenot satisfiable"</li><li>Try it with telnet !!! Why not fetching a single byte? bytes= 4-4 ... orthe last 10 bytes: bytes=-10 .. or multiple ranges: bytes=100-300, 500-999(you will get 100 - 999)</li></ul></ul><li>quitting/restarting the server does not invalidate the cache. As long asfiles are present they can be served.</li><li>limits:</li><ul><li>no replacing policy</li><li>ignores cache-control headers and Date, Age</li></ul></ul><li><b>Compability</b></li><ul><li>I did not encounter major browser or server incompabilities. I have testedSafari, IE, Avant-Browser, Firefox and even non-browser-based HTTP clientslike</li><br>QuickTime-Player, the iTunes-Music-Store. I surfed and surfed, fixedproblems, surfed, surfed until now I do not known of any real problems...<br>I have tested it with Java 1.4.2 under Mac OS X and Windows XP.</ul><li><b>Java-Code &amp; Implementation-Notes</b></li><ul><li>I've written lots of lines! I tried to incorporate as much of what I have(or should have) learned in my studies so far,</li><br>that is for example<ul><li>Reusability:</li><br>The http-package could be reused.<br>The Cache-classes are quite generic and extensible<li>I belive it is not very spaghettisch, althought the ProxyRequest is huge,but hey, I could be worse...</li></ul><li>does some basic HTTP/1.x validation</li><li>If you take a look at the cache-package and the concrete implementaionsProxyCacheMgr/Object you'll</li><br>notice lot of thread-synchronization that I had to learn... It mightlook complicated or too generic, but it is really not a hack!<br>I did my best, to avoid inconsistency and clients having to wait forother threads, when it is not really necessary. As far as I could testit, it works quite well. For example a threads cannot cache a documentto disk, while it is beeing written by another one. Instead of simply synchronizingor buffering, the second thread will only wait a specified amount of time(see <i>server.properties</i>) and then won't cache it. Documents beeingcached (streamed to disk, while transfered to client) are stored in a tmp-directoryand when complete moved into the main cache-directory (or removed on rollback)... there are many cases, and I tried to cope with all or most of them.Take a look at operationAvailable(int operation) in proxy.ProxyCacheObject.java..each critical operation can be<br>synchronized. If you access an object from the cache (e.g. for readingor writing) and you<br>do not want to depend on the CacheObject itself synchronizing youroperation, you can always use cache.CacheObject.waitForOperationAvailability(intoperation,long timeout) to prevent your code to block for a unknown time,you can tell how you long you are willing to wait for an operation. Ifthe timeout exceeds (indicated by an Exception), then you can decide tonot perform an operation, since it would still block. If you do not usethis method, the CacheObject and its CacheMgr will as in any case takecare for consistency, but possibly by blocking your code. This mechanismis used in proxy.ClientRequest.java to keep the control-flow non blocking.<br>Do not be confused and believe there are lots of situation where blockingcan occur... I'll first describe how the cache generally works.<br>&nbsp;<ul><li>on a request check if the file exists in the cache (check if a fiel existsin the cache directory)</li><ul><li>yes -> get a InputStream and serve it. The corresponing CacheObject flagnow has the 'reading'-bit. when the transfer is complete, or there is anException during transfer the stream is closed() and the CacheObject's'reading'-flag is unset.</li><li>no &amp;&amp; cacheable -> get a OutputStream to a temporary-file in cache/tmp-directory.Write bytes to client and disk. Set the CacheObject's 'writing'-flag. Nowhen transfer is done because...</li><ul><li>... all bytes have been transferred</li><ul><li>the stream is closed and if the CacheObject's 'valid' flag is true thenpeform it's commit-operation, wich simply means unsetting the 'reading'-flagand setting the 'commit'-flag ... now you can safely move the temporary-fileto the main cache-directory where it can be served.</li><li>transfer is not complete due to an exception (I/O)... the CacheObject's'valid'-falg will be false,</li><br>so when closing the stream a rollback-operation will be performed similarto commit(). the temporary-file will be removed.<br>&nbsp;</ul></ul></ul></ul>All those steps are beeing synchronized by the common Java-mechanisms.<p>For example try to load a large Website with many images etc. and thenafter a second or a half press the cancel/stop button of your browser and<br>look at the console.. You will see that the corrupted/incomplete transferswich are not supposed to find their way into the cache are beeing invalidatedand removed (rollback).<p>..and finally ... I am sorry, but there is not always good javadoc.<li>See http.io.BufferdInputStream for how I "solved" the <i><font color="#FF0000">readLine()-Issue</font></i>.I manually take care for \n \r characters... I found the readLine()-methodon the internet, but I adapted it to fit to an InputStream, by overridingseveral read()-methods. Basically it is an InputStream for reading binary-data,but also supoorts a readLine()-method that reads bytes until the firstvalid line-separator is encountered. It can cope with CR,LF,CRLF line-separators.After implementing the read()-methods I did not have any problems usingthe readLine()-method and transferring binary-data afterwards.</li></ul><li><b>Compiling, Installing , Running</b></li><ul><li>I used eclipse to built it, but I have provided a script to compile iton the command line. build.sh should work on *NIX platforms, while thebat files were only roughly tested.</li><p><br><i>There are .BAT scripts for MS-DOS too.</i><p><b>?> sh build.sh</b>&nbsp;&nbsp;&nbsp; (compiles sources from src-dirto classes-dir)<br><b>?> sh init.sh</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (creates cache-directoryand toc.html file)&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#FF0000">IMPORTANT:without those directories and file the program does not work properly</font></b>!!!!<br><b>?> sh server.sh &lt;port></b> (start the server)<br>&nbsp;<font color="#000000"></font><p><font color="#000000">edit <i>server.properties</i> and <i>log4j.properties</i>if you wish !</font><p>to clear the cache you could use<p><b>?> sh clear_cache.sh</b><p><b>The User-Interface:</b><br>You'll notice the prompt ?><br>Type 'help' for some commands.<p><b>help - </b>help<br><b>quit&nbsp; - </b>quit, but will wait for threads to terminate.<br><b>status - </b>prints out a snapshot of the cache status (reading/writinghow many threads are interested in a resource...)<br><b>gc - </b>run the System.gc() - garbage collector<p>depending on log4j.properties you will see lots of INFO-loggings, someof them are worth reading.<br>&nbsp;<p>depending on the property 'monitor_task_schedule' in server.propertiesthe cache-status will be printed occasionally.<br>It's a snapshot of the cache's current activities. It's a TimerTaskwich repeatedly&nbsp; (every xyz ms) prints out a snapshot of the cache-status,but only if there actually is activity. That's why I said occasionally.<br>So if the server is not serving any clients, you should never see thecache-status, except its state is corrupted, or, of course, if you explicitlyinvoke it with the 'status'-command.<p>&nbsp;<br>&nbsp;<p>Probably I forgot many things that I would have liked to say....havefun!<br>&nbsp;</ul></ul></body></html>